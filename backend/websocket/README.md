# Краткий обзор работы вебсокет сервера

При вызове WSServer.start запускаются 2 параллельных задачи:

1. Обработка входящих соединений и коммуникаций с ними.
2. Цикл сбора данных индикаторов с tradingview, вычисления рекомендаций и рассылка этих рекомендаций подписчикам.
   Интервал ~20 секунд (по умолчанию).

**Авторизация пользователя происходит по токену сгенерированному при общении с ботом, чтобы усложнить несанкционированный
доступ к вебсокету. Пока токен содержит только telegram id пользователья в зашифрованном виде. Можно еще добавить
сегодняшнюю дату для того, чтобы нельзя было пользоваться одним и тем же токеном больше суток, например. По этому id
осуществляется поиск аккаунта в базе, и если все хорошо - предоставляется доступ.**

У каждого подключения есть состояние:

```py
self.conns = {
    conn1: {
        # telegram user id
        "tg_uid": tg_uid,
        # Подписки на получение полного количества индикаторов
        "subs": {
            ("USDCAD", "1m"): {
                # Последние рекомендации отправленные по данному ключу
                "last_rcms" : { ... }
            }, 
            ("USDCHF", "5m"): {
                "last_rcms" : { ... }
            }
        },
        # Подписки на получение только индикатора "Recommend.All"
        "subs2": {
            ("AUDCAD", "1m"): {
                "last_rcms2" : { ... }
            }
        }
    },

    conn2: {
        # тот же принцип, что и в conn1
        ...
    }
    ...
}
```

После открытия/закрытия нового подключения, либо создание/отмены подписки на получение рекомендаций по символу с
таймфреймом `(symbol, tf)`, создается соответствующая задача `task`, которая добавляется в очередь задач `taskq`. Каждый
виток цикла №2 из очереди извлекаются несколько задач и исполняются в последовательном порядке, чтобы избежать
конфликтов при доступе к общим ресурсам класса.

Каждый виток цикла №2 происходит группировка символов с таймфреймами для всех подключений.

Пример:

```py

# Список кортежей    
[
    ('USDJPY', '1m'), 
    ('USDJPY', '5m'), 
    ('NZDUSD', '1m'), 
    ('NZDUSD', '5m'), 
    ('USDCHF', '1m'), 
    ('USDCHF', '5m')
]

# Преобразуется в словарь
{ 
    ('1m', '5m'): [
        'USDJPY', 
        'USDCHF',
        'NZDUSD',
    ],
}
```

Сделано это для того, чтобы уменьшить количество запросов к tradingview. Так как иммено такая форма запроса позволяет
получить наибольшее количество данных за одно обращение к tradingview.

То есть из предыдущего примера получится 1 запрос вместо 3х если группировать по символам или вместо 2х если
группировать по таймфреймам:

```py
# Данные для post запроса к tradingview
data = json.dumps({
    "symbols": {
        "tickers": [            # Перечень символов
            "FX_IDC:USDJPY", 
            "FX_IDC:USDCHF", 
            "FX_IDC:NZDUSD", 
        ],  
        "query": {
            "types": []
        }
    }, 
    "columns": [                # Перечень "Индикатор|таймфрейм"
        "Recommend.All|1",
        "Recommend.All|5",
        "Stoch.D|1",
        "Stoch.D|5",
        "CCI20|1",
        "CCI20|5",
        ...                     # и так далее
    ]       
})
```

Вновь подключившийся пользователь получит данные сразу при подключении, если аналогичная подписка уже существует и
данные для нее уже скачаны в предыдущем цикле.

Скачивание данных по умолчанию происходит конкурентно через tor proxy.

Если пользователь сменил вкладку в браузере - соединение будет закрыто (подписка будет отменена автоматически) и
откроется только когда он вернется на вкладку.